<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
  <meta http-equiv="Pragma" content="no-cache"/>
  <meta http-equiv="Expires" content="0"/>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Aquaponics Sensor Dashboard</title>

  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">

  <!-- Chart.js + time adapter -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>

  <style>
    :root{
      --bg:#f8fafc; --card:#fff; --card-border:#e5e7eb; --text:#0f172a; --muted:#64748b;
      --ph:#e11d48; --ph-fill:#e11d4826;
      --tds:#0284c7; --tds-fill:#0284c726;
      --temp:#d97706; --temp-fill:#d9770626;
    }
    *{box-sizing:border-box}
    body{margin:0; font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
         color:var(--text); background:var(--bg); padding:24px;}
    header{display:flex; align-items:flex-start; gap:18px; flex-wrap:wrap; margin-bottom: 18px;}
    h1{margin:0; font-size:28px; letter-spacing:.3px}
    .note{color:var(--muted); font-size:13px}
    .bar{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .chip{padding:8px 12px; border-radius:999px; background:#fff; border:1px solid var(--card-border);
          font-size:13px; display:inline-flex; align-items:center; gap:8px;
          box-shadow:0 6px 18px rgba(2,6,23,.08);}
    .dot{width:10px; height:10px; border-radius:999px; display:inline-block}
    .dot.ph{background:var(--ph)} .dot.tds{background:var(--tds)} .dot.temp{background:var(--temp)}
    h2{margin:22px 0 10px; font-size:18px; color:#111827; letter-spacing:.3px}
    .grid{display:grid; gap:16px; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));}
    .card{background:var(--card); border:1px solid var(--card-border); border-radius:16px; padding:14px;
          box-shadow:0 10px 30px rgba(2,6,23,.06); min-height:320px; display:flex; flex-direction:column;}
    .card h3{margin:0 0 10px; font-size:14px; color:#1f2937; font-weight:600}
    .chartbox{ position:relative; height:260px; width:100%; }
    canvas{ display:block; width:100%; height:100%; }
    footer{margin-top:26px; color:var(--muted); font-size:12px}
    a{color:#0369a1}

    /* Water Coach floating panel */
    #coach{ position:fixed; right:16px; bottom:16px; z-index:50; max-width:360px;
      background:#fff; border:1px solid var(--card-border); border-radius:12px;
      box-shadow:0 10px 30px rgba(2,6,23,.10); padding:12px; font: 13px/1.4 Inter, system-ui;}
    #coach .badge{ display:inline-block; font-size:11px; padding:2px 8px; border-radius:999px; border:1px solid var(--card-border); margin-left:8px;}
    #coach .badge.ok{ background:#e8f5e9; color:#166534; border-color:#bbf7d0;}
    #coach .badge.watch{ background:#fff7ed; color:#a16207; border-color:#fde68a;}
    #coach .badge.alert{ background:#fef2f2; color:#991b1b; border-color:#fecaca;}
    #coach ul{ margin:6px 0 0; padding-left:18px;}
  </style>

<!-- inject: utc-bucketing + cache-bust -->
<script>
(function(){
  if (window.__aquap_patch__) return;  // idempotent
  window.__aquap_patch__ = true;

  // 1) Make any toLocaleDateString() return a UTC yyyy-mm-dd key
  try {
    const _orig = Date.prototype.toLocaleDateString;
    Date.prototype.toLocaleDateString = function(){
      try { return this.toISOString().slice(0,10); }
      catch(e){ return _orig.call(this); }
    };
  } catch (e) {}

  // 2) Always fetch fresh JSON for data.json / coach.json
  try {
    const _fetch = window.fetch.bind(window);
    window.fetch = function(u, opts){
      try {
        if (typeof u === "string" &&
            (u.endsWith("data.json") || u.endsWith("coach.json"))) {
          const t = Date.now();
          u = u + (u.includes("?") ? "&" : "?") + "v=" + t;
        }
      } catch(e) {}
      return _fetch(u, opts);
    };
  } catch (e) {}

  // 3) Hint windows (in case the page reads these globals)
  window.RAW_WINDOW_DAYS = 7;
  window.DAILY_WINDOW_DAYS = 30;
})();
</script>
<!-- /inject -->

</head>
<body>
  <header>
    <div>
      <h1>Aquaponics Sensor Dashboard</h1>
      <div class="note">Live from <code>data.json</code> • Last refresh: <span id="ts"></span> • Auto refresh every 30 min</div>
    </div>
    <div class="bar" id="latestChips" aria-live="polite"></div>
  </header>

  <h2>Last 7 Days — Raw Readings</h2>
  <div class="grid">
    <div class="card"><h3>pH (raw)</h3><div class="chartbox"><canvas id="ph7"></canvas></div></div>
    <div class="card"><h3>TDS (ppm, raw)</h3><div class="chartbox"><canvas id="tds7"></canvas></div></div>
    <div class="card"><h3>Water Temp (°C, raw)</h3><div class="chartbox"><canvas id="temp7"></canvas></div></div>
  </div>

  <h2>Last 30 Days — Daily Averages</h2>
  <div class="grid">
    <div class="card"><h3>Daily Avg pH</h3><div class="chartbox"><canvas id="ph30"></canvas></div></div>
    <div class="card"><h3>Daily Avg TDS (ppm)</h3><div class="chartbox"><canvas id="tds30"></canvas></div></div>
    <div class="card"><h3>Daily Avg Temp (°C)</h3><div class="chartbox"><canvas id="temp30"></canvas></div></div>
  </div>

  <footer>
    Keep at least 30–60 days of data on the Pi (<code>WINDOW_DAYS=60</code>) so daily-average charts stay full.
  </footer>

  <!-- Water Coach panel -->
  <div id="coach" role="complementary" aria-label="Water Coach">
    <div style="font-weight:600; margin-bottom:6px;">
      Water Coach <span id="coach-status" class="badge">loading…</span>
    </div>
    <div id="coach-ts" style="color:#64748b; font-size:12px; margin-bottom:8px;">…</div>
    <div id="coach-body">Loading advice…</div>
  </div>

<script>
  function nocache(u){ const n=Date.now(); return u+(u.includes("?")?"&":"?")+"v="+n; }
  // ---------- utilities ----------
  const TZ = Intl.DateTimeFormat().resolvedOptions().timeZone;
  const MS_DAY = 24*60*60*1000;
  const now = new Date();
  const cutoff7  = new Date(now.getTime() - 7*MS_DAY);
  const cutoff30 = new Date(now.getTime() - 30*MS_DAY);

  const fmtNum = (v, digits=3) => (Number.isFinite(v) ? Number(v).toFixed(digits) : "—");
  const fmtChip = (label, v) => `<span class="chip"><span class="dot ${label}"></span>${label.toUpperCase()}: ${fmtNum(v, label==='tds'?1:2)}${label==='tds'?' ppm': (label==='temp'?' °C':'')}</span>`;

  function parseTS(s){ return new Date(String(s)); } // handles "...Z" cleanly
  function toPoint(r, key){
    const y = Number(r[key]);
    if (!Number.isFinite(y)) return null;    // drop None/nulls
    return { x: parseTS(r.timestamp), y };
  }

  function groupDailyAvg(points){
    // points: array of {x: Date, y: number}
    const buckets = new Map(); // key: yyyy-mm-dd (local)
    for(const p of points){
      if(!p) continue;
      const d = new Date(p.x);
      const key = d.getFullYear()+"-"+String(d.getMonth()+1).padStart(2,'0')+"-"+String(d.getDate()).padStart(2,'0');
      let b = buckets.get(key);
      if(!b) { b = { sum:0, n:0, day: new Date(d.getFullYear(), d.getMonth(), d.getDate(), 12,0,0) }; buckets.set(key,b); }
      b.sum += p.y; b.n += 1;
    }
    return Array.from(buckets.values())
      .map(b => ({ x: b.day, y: b.sum/b.n }))
      .sort((a,b) => a.x - b.x);
  }

  // ---------- chart helpers ----------
  function makeLine(ctx, label, color, data){
    return new Chart(ctx, {
      type: 'line',
      data: {
        datasets: [{
          label,
          data,               // [{x, y}, ...]
          borderColor: color,
          backgroundColor: color+'26',
          tension: 0.25,
          radius: 0,
          spanGaps: true
        }]
      },
      options: {
        parsing: false,       // we're giving {x,y}
        animation: false,
        scales: {
          x: {
            type: 'time',
            time: { unit: 'day', tooltipFormat: "PPpp" }
          },
          y: { beginAtZero: false, ticks: { maxTicksLimit: 6 } }
        },
        plugins: {
          legend: { display: true },
          tooltip: {
            callbacks: {
              label: (ctx) => `${ctx.dataset.label}: ${fmtNum(ctx.parsed.y, ctx.dataset.label?.includes('TDS')?1:2)}${ctx.dataset.label?.includes('TDS')?' ppm': (ctx.dataset.label?.includes('Temp')?' °C':'')}`
            }
          }
        }
      }
    });
  }

  // ---------- fetch + render ----------
  document.getElementById('ts').textContent = new Date().toLocaleString();

  Promise.all([
    fetch('data.json',  {cache:'no-store'}).then(r => r.json()),
    fetch('coach.json', {cache:'no-store'}).then(r => r.json()).catch(()=>null)
  ]).then(([rows, coach]) => {
    // Latest chips (last row in file is latest)
    const latest = rows.at(-1) || {};
    const chips = [
      ['ph',   latest.ph],
      ['tds',  latest.tds],
      ['temp', latest.temp_c]
    ].map(([k,v]) => fmtChip(k, v)).join('');
    document.getElementById('latestChips').innerHTML = chips;

    // Transform to points
    const rawPoints = rows.map(r => ({
      ph:   toPoint(r,'ph'),
      tds:  toPoint(r,'tds'),
      temp: toPoint(r,'temp_c')
    }));

    // 7-day raw (filter by cutoff)
    const ph7   = rawPoints.map(p=>p.ph).filter(p=>p && p.x>=cutoff7);
    const tds7  = rawPoints.map(p=>p.tds).filter(p=>p && p.x>=cutoff7);
    const temp7 = rawPoints.map(p=>p.temp).filter(p=>p && p.x>=cutoff7);

    // 30-day daily averages
    const ph30   = groupDailyAvg(rawPoints.map(p=>p.ph).filter(Boolean).filter(p=>p.x>=cutoff30));
    const tds30  = groupDailyAvg(rawPoints.map(p=>p.tds).filter(Boolean).filter(p=>p.x>=cutoff30));
    const temp30 = groupDailyAvg(rawPoints.map(p=>p.temp).filter(Boolean).filter(p=>p.x>=cutoff30));

    // Render charts
    makeLine(document.getElementById('ph7'),   'pH',            getCss('--ph'),   ph7);
    makeLine(document.getElementById('tds7'),  'TDS (ppm)',     getCss('--tds'),  tds7);
    makeLine(document.getElementById('temp7'), 'Water Temp (°C)', getCss('--temp'), temp7);

    makeLine(document.getElementById('ph30'),   'Daily Avg pH',        getCss('--ph'),   ph30);
    makeLine(document.getElementById('tds30'),  'Daily Avg TDS (ppm)', getCss('--tds'),  tds30);
    makeLine(document.getElementById('temp30'), 'Daily Avg Temp (°C)', getCss('--temp'), temp30);

    // Coach panel (if available)
    if (coach && coach.status) {
      const status = String(coach.status).toLowerCase();
      const badge = document.getElementById('coach-status');
      badge.textContent = status;
      badge.classList.remove('ok','watch','alert');
      badge.classList.add(status);
      document.getElementById('coach-ts').textContent =
        new Date(coach.timestamp || Date.now()).toLocaleString();

      const items = (coach.insights||[]).map(i => {
        const m = (i.metric||'').toUpperCase();
        return `<li><b>${m}:</b> ${i.recommendation||''}</li>`;
      }).join('');
      document.getElementById('coach-body').innerHTML =
        `<div>${coach.summary||''}</div><ul>${items}</ul>`;
    } else {
      document.getElementById('coach').style.display = 'none';
    }
  });

  function getCss(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

  // Auto-refresh every 30 minutes
  setInterval(()=>location.reload(), 30*60*1000);
</script>

<!-- aquaponics: force UTC daily averages for last 30d -->
<script>
(function(){
  if (window.__aquap_daily_fix__) return; 
  window.__aquap_daily_fix__ = true;

  function toDayUTC(ts){
    try { return new Date(ts).toISOString().slice(0,10); } catch(e){ return null; }
  }

  function buildDailyUTC(rows){
    const sums = new Map(); // day -> {c, ph, tds, temp}
    for (const r of rows){
      const d = toDayUTC(r.timestamp);
      if (!d) continue;
      const v = sums.get(d) || {c:0, ph:0, tds:0, temp:0};
      if (typeof r.ph === 'number')  v.ph  += r.ph;
      if (typeof r.tds === 'number') v.tds += r.tds;
      if (typeof r.temp_c === 'number') v.temp += r.temp_c;
      v.c += 1;
      sums.set(d, v);
    }
    // last 30 UTC days timeline
    const now = new Date();
    const labels = [];
    const ph = [], tds = [], temp = [];
    for (let i=29;i>=0;i--){
      const d = new Date(Date.UTC(
        now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()-i
      )).toISOString().slice(0,10);
      labels.push(d);
      const v = sums.get(d);
      ph.push(v && v.c ? +(v.ph/v.c).toFixed(3) : null);
      tds.push(v && v.c ? +(v.tds/v.c).toFixed(1) : null);
      temp.push(v && v.c ? +(v.temp/v.c).toFixed(2) : null);
    }
    return {labels, ph, tds, temp};
  }

  // Hook fetch so we see data.json when your code loads it
  const _fetch = window.fetch;
  window.fetch = function(input, init){
    const url = (typeof input === 'string') ? input : (input && input.url) || '';
    const p = _fetch.call(this, input, init);
    if (/data\.json/.test(url)){
      p.then(r => r.clone().json().then(rows => {
        // After charts exist, patch them once
        setTimeout(() => {
          try {
            const d = buildDailyUTC(rows);
            // Find canvases by card titles then update the Chart.js instance for each
            function chartByCardTitle(sub){
              const cards = Array.from(document.querySelectorAll('.card'));
              for (const c of cards){
                const h = c.querySelector('h3');
                const cvs = c.querySelector('canvas');
                if (h && cvs && h.textContent.toLowerCase().includes(sub)) {
                  // Chart.js v3+: Chart.getChart(canvas) gives the instance
                  const inst = window.Chart && window.Chart.getChart ? window.Chart.getChart(cvs) : null;
                  if (inst) return inst;
                }
              }
              return null;
            }
            const phChart   = chartByCardTitle('daily avg ph');
            const tdsChart  = chartByCardTitle('daily avg tds');
            const tmpChart  = chartByCardTitle('daily avg temp');

            if (phChart){
              phChart.data.labels = d.labels;
              if (phChart.data.datasets[0]) phChart.data.datasets[0].data = d.ph;
              phChart.update('none');
            }
            if (tdsChart){
              tdsChart.data.labels = d.labels;
              if (tdsChart.data.datasets[0]) tdsChart.data.datasets[0].data = d.tds;
              tdsChart.update('none');
            }
            if (tmpChart){
              tmpChart.data.labels = d.labels;
              if (tmpChart.data.datasets[0]) tmpChart.data.datasets[0].data = d.temp;
              tmpChart.update('none');
            }
          } catch (e) { console.warn('daily fix error:', e); }
        }, 250); // let the page finish building charts
      })).catch(()=>{});
    }
    return p;
  };

  // Ensure JSON fetches are always cache-busted
  if (!window.nocache) window.nocache = u => u + (u.includes('?')?'&':'?') + 'v=' + Date.now();
})();
</script>

</body>
</html>
